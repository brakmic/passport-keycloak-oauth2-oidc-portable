# PKCE

## Table of Contents

1. [Introduction](#introduction)
2. [Understanding PKCE](#understanding-pkce)
    - [What is PKCE?](#what-is-pkce)
    - [Key Components of PKCE](#key-components-of-pkce)
3. [PKCE Flow Overview](#pkce-flow-overview)
    - [ASCII Diagram](#ascii-diagram)
    - [Detailed Flow Description](#detailed-flow-description)
4. [Integrating PKCE with Keycloak and Passport.js](#integrating-pkce-with-keycloak-and-passportjs)
    - [Client Implementation](#client-implementation)
    - [Custom KeycloakStrategy](#custom-keycloakstrategy)
5. [Step-by-Step PKCE Process](#step-by-step-pkce-process)
    - [1. Generating Code Verifier and Code Challenge](#1-generating-code-verifier-and-code-challenge)
    - [2. Initiating the Authorization Request](#2-initiating-the-authorization-request)
    - [3. Handling the Authorization Response](#3-handling-the-authorization-response)
    - [4. Exchanging Authorization Code for Tokens](#4-exchanging-authorization-code-for-tokens)
    - [5. Accessing Protected Resources](#5-accessing-protected-resources)
6. [Advantages of Using PKCE](#advantages-of-using-pkce)
7. [When and Where to Use PKCE](#when-and-where-to-use-pkce)
8. [Code Implementation Details](#code-implementation-details)
    - [Client Code](#client-code)
    - [KeycloakStrategy](#keycloakstrategy)
9. [Code Snippets](#code-snippets)
    - [Generating Code Verifier and Code Challenge](#generating-code-verifier-and-code-challenge)
    - [Authorization Parameters in KeycloakStrategy](#authorization-parameters-in-keycloakstrategy)
    - [Token Parameters in KeycloakStrategy](#token-parameters-in-keycloakstrategy)
    - [Client Authentication Flow](#client-authentication-flow)
10. [Conclusion](#conclusion)

---

## Introduction

In modern web applications, securing authentication and authorization processes is paramount. **Proof Key for Code Exchange (PKCE)** is an extension to the OAuth 2.0 authorization framework that enhances security, especially for public clients unable to securely store client secrets. This document delves into PKCE, elucidates its workflow, and demonstrates its integration with **Keycloak** using a custom **Passport.js** strategy written in TypeScript.

## Understanding PKCE

### What is PKCE?

**Proof Key for Code Exchange (PKCE)**, pronounced "pixy," is an OAuth 2.0 extension designed to prevent authorization code interception attacks. Initially crafted for mobile and native applications, PKCE is now recommended for all types of OAuth clients, including single-page applications and other public clients.

### Key Components of PKCE

1. **Code Verifier**: A high-entropy cryptographic random string generated by the client. It serves as a secret used to validate the authorization request.
2. **Code Challenge**: A transformation of the code verifier, typically using SHA-256 hashing followed by Base64 URL encoding. This is sent to the authorization server during the initial authorization request.
3. **Authorization Code**: A temporary code received from the authorization server upon successful user authentication. It is exchanged for access tokens.
4. **Code Challenge Method**: Specifies the method used to derive the code challenge from the code verifier. Commonly, `S256` (SHA-256) is used.

## PKCE Flow Overview


```
+--------+                                +-------------------+                                +-----------------+
|        |                                |                   |                                |                 |
|  User  |                                |   Client App      |                                | Keycloak Auth   |
|Browser |                                |                   |                                |    Server       |
|        |                                |                   |                                |                 |
+---+----+                                +---------+---------+                                +--------+--------+
    |                                             |                                                     |
    | (A) User initiates login                    |                                                     |
    |-------------------------------------------->|                                                     |
    |                                             |                                                     |
    |                                             | (B) Generate code_verifier & code_challenge         |
    |                                             |---------------------------------------------------> |
    |                                             |                                                     |
    |                                             | (C) Redirect to Keycloak with code_challenge        |
    |                                             |<--------------------------------------------------- |
    |                                             |                                                     |
    | (D) User authenticates & consents           |                                                     |
    |-------------------------------------------->|                                                     |
    |                                             |                                                     |
    |                                             | (E) Keycloak redirects to callback with code        |
    |                                             |---------------------------------------------------> |
    |                                             |                                                     |
    |                                             |                                                     |
    |                                             | (F) Client receives code & retrieves code_verifier  |
    |                                             |                                                     |
    |                                             | (G) Client requests tokens with code & code_verifier|
    |                                             |---------------------------------------------------> |
    |                                             |                                                     |
    |                                             | (H) Keycloak validates code_verifier & issues tokens|
    |                                             |<--------------------------------------------------- |
    |                                             |                                                     |
    |                                             | (I) Client receives access token                    |
    |                                             |                                                     |
    | (J) Access protected resources              |                                                     |
    |-------------------------------------------->|                                                     |
    |                                             |                                                     |
+--------+                                +---------+---------+                                +-----------------+
|        |                                |                   |                                |                 |
|Resource|                                |                   |                                |                 |
| Server |                                |                   |                                |                 |
|        |                                |                   |                                |                 |
+--------+                                +-------------------+                                +-----------------+
```

**Legend:**
- **(A)**: User initiates the login process on the Client Application.
- **(B)**: Client generates a `code_verifier` and derives a `code_challenge` using SHA-256.
- **(C)**: Client redirects the user's browser to Keycloak's authorization endpoint, including the `code_challenge` and specifying the `code_challenge_method` as `S256`.
- **(D)**: User authenticates with Keycloak and consents to the requested scopes.
- **(E)**: Upon successful authentication, Keycloak redirects the browser back to the Client's callback URL with an authorization code.
- **(F)**: Client receives the authorization code and retrieves the previously stored `code_verifier` from the session.
- **(G)**: Client sends a token request to Keycloak's token endpoint, including the authorization code and the `code_verifier`.
- **(H)**: Keycloak verifies that the `code_verifier` matches the `code_challenge` and, upon validation, issues access (and optionally refresh) tokens.
- **(I)**: Client receives the access token from Keycloak.
- **(J)**: Client uses the access token to access protected resources on the Resource Server.

---

This diagram illustrates each step of the PKCE flow, highlighting the interactions between the user's browser, the client application, Keycloak's authorization server, and the resource server. By following this sequence, PKCE ensures a secure exchange of authorization codes and access tokens, mitigating potential interception attacks.

## Integrating PKCE with Keycloak and Passport.js

Implementing PKCE with Keycloak involves configuring both the client application and the authentication strategy used to communicate with Keycloak. In this setup, we utilize a custom Passport.js strategy, `KeycloakStrategy`, built upon the `passport-oauth2` library, to handle the OAuth 2.0 flow with PKCE.

### Client Implementation

The client application manages the OAuth flow, generates PKCE parameters, and maintains user sessions. Key aspects include:

- **Generating PKCE Parameters**: Creating a `code_verifier` and deriving a `code_challenge`.
- **Session Management**: Storing the `code_verifier` in the user's session for later verification.
- **Authentication Routes**: Defining routes to initiate authentication, handle callbacks, and display user profiles.

### Custom KeycloakStrategy

`KeycloakStrategy` extends `OAuth2Strategy` from `passport-oauth2` to incorporate PKCE-specific parameters into the authorization and token requests. It handles:

- **Authorization Parameters**: Injecting `code_challenge` and `code_challenge_method` into authorization requests.
- **Token Parameters**: Including the `code_verifier` during the token exchange.
- **User Profile Retrieval**: Fetching and parsing user information from Keycloak's userinfo endpoint.

## Step-by-Step PKCE Process

### 1. Generating Code Verifier and Code Challenge

**Code Verifier**: A high-entropy string, typically between 43 and 128 characters, composed of URL-safe characters.

**Code Challenge**: Derived from the code verifier using SHA-256 hashing and Base64 URL encoding.

**Implementation in Client Code**:

```typescript
function generateCodeVerifier(length = 128): string {
  const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
  return Array.from({ length }, () => possible.charAt(Math.floor(Math.random() * possible.length))).join('');
}

function generateCodeChallenge(code_verifier: string): string {
  return crypto.createHash('sha256').update(code_verifier).digest('base64url');
}
```

### 2. Initiating the Authorization Request

The client initiates the OAuth flow by redirecting the user to Keycloak's authorization endpoint, including PKCE parameters:

- **code_challenge**: Derived from the code verifier.
- **code_challenge_method**: Specifies the method used (`S256` for SHA-256).

**Implementation in Client Code**:

```typescript
app.get('/auth/keycloak', (req: Request, res: Response, next: NextFunction) => {
  let code_verifier: string | null = null;
  let code_challenge: string | null = null;

  if (argv['use-pkce']) {
    code_verifier = generateCodeVerifier();
    code_challenge = generateCodeChallenge(code_verifier);
    req.session.code_verifier = code_verifier;
  }

  passport.authenticate('keycloak', {
    scope: ['openid', 'profile', 'email'],
    ...(argv['use-pkce'] && {
      code_challenge: code_challenge,
      code_challenge_method: 'S256',
    }),
  })(req, res, next);
});
```

### 3. Handling the Authorization Response

After user authentication, Keycloak redirects back to the client's callback URL with an authorization code.

**Implementation in Client Code**:

```typescript
app.get('/auth/keycloak/callback', (req: Request, res: Response, next: NextFunction) => {
  passport.authenticate('keycloak', (err: any, user: any, info: any) => {
    if (err) {
      return res.status(500).send('Internal Server Error during authentication.');
    }

    if (!user) {
      return res.redirect('/login');
    }

    req.logIn(user, (err) => {
      if (err) {
        return res.status(500).send('Internal Server Error during login.');
      }
      return res.redirect('/profile');
    });
  })(req, res, next);
});
```

### 4. Exchanging Authorization Code for Tokens

The client exchanges the received authorization code for access tokens by sending a request to Keycloak's token endpoint, including the original `code_verifier`.

**Implementation in KeycloakStrategy**:

```typescript
tokenParams(options: any): any {
  const params: any = {};

  if (options.req && options.req.session && options.req.session.code_verifier) {
    params.code_verifier = options.req.session.code_verifier;
  }

  return params;
}
```

### 5. Accessing Protected Resources

With the access token obtained, the client can now access protected resources or APIs on behalf of the user.

## Advantages of Using PKCE

1. **Enhanced Security**: Binds the authorization request to the client by requiring the correct code verifier during the token exchange.
2. **No Need for Client Secrets**: Ideal for public clients that cannot securely store secrets, reducing the risk associated with exposed client credentials.
3. **Protection Against Interception Attacks**: Prevents malicious actors from using intercepted authorization codes without the correct code verifier.
4. **Compliance with OAuth 2.0 Best Practices**: Aligns with modern security recommendations, ensuring robust authentication flows.

## When and Where to Use PKCE

PKCE is particularly beneficial in scenarios where:

- **Public Clients**: Applications like single-page apps, mobile apps, or any client that cannot securely store a client secret.
- **High-Security Applications**: Systems handling sensitive user data requiring stringent security measures.
- **Modern OAuth Implementations**: Adopting the latest OAuth 2.0 standards to ensure compatibility and security.

## Code Implementation Details

### Client Code

The client manages the OAuth flow, generates PKCE parameters, and handles user sessions. Key components include:

- **Session Management**: Uses `express-session` to store PKCE-related data (`code_verifier`).
- **Authentication Routes**: Defines endpoints to initiate authentication and handle callbacks.
- **PKCE Parameter Generation**: Generates `code_verifier` and `code_challenge` when PKCE is enabled.

### KeycloakStrategy

A custom Passport.js strategy that integrates PKCE into the OAuth 2.0 flow with Keycloak. It extends `OAuth2Strategy` and overrides specific methods to include PKCE parameters.

- **authorizationParams**: Adds `code_challenge` and `code_challenge_method` to the authorization request.
- **tokenParams**: Includes the `code_verifier` during the token exchange.
- **userProfile**: Retrieves and parses user information from Keycloak's userinfo endpoint.

## Code Snippets

### Generating Code Verifier and Code Challenge

```typescript
/**
 * Function to generate a random string for code_verifier.
 */
function generateCodeVerifier(length = 128): string {
  const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
  return Array.from({ length }, () => possible.charAt(Math.floor(Math.random() * possible.length))).join('');
}

/**
 * Function to generate code_challenge from code_verifier.
 */
function generateCodeChallenge(code_verifier: string): string {
  return crypto.createHash('sha256').update(code_verifier).digest('base64url');
}
```

**Explanation**: The `generateCodeVerifier` function creates a high-entropy, URL-safe string, while the `generateCodeChallenge` function derives a SHA-256 hash of the verifier and encodes it in Base64 URL format.

### Authorization Parameters in KeycloakStrategy

```typescript
/**
 * Override the authorizationParams method to include PKCE parameters.
 */
authorizationParams(options: any): any {
  const params: any = super.authorizationParams(options);

  if (options.code_challenge) {
    params.code_challenge = options.code_challenge;
    params.code_challenge_method = 'S256';
  }

  return params;
}
```

**Explanation**: This method ensures that when PKCE is enabled, the `code_challenge` and its method (`S256`) are included in the authorization request sent to Keycloak.

### Token Parameters in KeycloakStrategy

```typescript
/**
 * Override the tokenParams method to include code_verifier from session.
 */
tokenParams(options: any): any {
  const params: any = {};

  if (options.req && options.req.session && options.req.session.code_verifier) {
    params.code_verifier = options.req.session.code_verifier;
  }

  return params;
}
```

**Explanation**: During the token exchange, this method retrieves the `code_verifier` stored in the user's session and includes it in the token request to Keycloak, completing the PKCE flow.

### Client Authentication Flow

```typescript
/**
 * Initiates authentication with Keycloak.
 */
app.get('/auth/keycloak', (req: Request, res: Response, next: NextFunction) => {
  let code_verifier: string | null = null;
  let code_challenge: string | null = null;

  if (argv['use-pkce']) {
    code_verifier = generateCodeVerifier();
    code_challenge = generateCodeChallenge(code_verifier);
    req.session.code_verifier = code_verifier;
  }

  // Initiate authentication.
  passport.authenticate('keycloak', {
    scope: ['openid', 'profile', 'email'],
    ...(argv['use-pkce'] && {
      code_challenge: code_challenge,
      code_challenge_method: 'S256',
    }),
  })(req, res, next);
});
```

**Explanation**: This route initiates the authentication process. If PKCE is enabled (`use-pkce` flag), it generates the `code_verifier` and `code_challenge`, stores the verifier in the session, and includes the challenge in the authorization request sent to Keycloak.

## Conclusion

Implementing **PKCE** with **Keycloak** significantly fortifies the OAuth 2.0 authorization code flow by mitigating risks associated with authorization code interception. Through the integration of a custom **Passport.js** strategy, developers can seamlessly incorporate PKCE into their authentication mechanisms, ensuring that public clients operate securely without relying on client secrets.
